{"ast":null,"code":"import { settings } from 'carbon-components';\nvar prefix = settings.prefix;\nexport function resetFocus(el) {\n  if (el) {\n    var _el$querySelectorAll;\n\n    Array.from((_el$querySelectorAll = el.querySelectorAll('[tabindex=\"0\"]')) !== null && _el$querySelectorAll !== void 0 ? _el$querySelectorAll : []).forEach(function (node) {\n      node.tabIndex = -1;\n    });\n  }\n}\nexport function focusNode(node) {\n  if (node) {\n    node.tabIndex = 0;\n    node.focus();\n  }\n}\nexport function getValidNodes(list) {\n  var level = list.dataset.level;\n  var nodes = [];\n\n  if (level) {\n    var submenus = Array.from(list.querySelectorAll('[data-level]'));\n    nodes = Array.from(list.querySelectorAll(\"li.\".concat(prefix, \"--menu-option\"))).filter(function (child) {\n      return !submenus.some(function (submenu) {\n        return submenu.contains(child);\n      });\n    });\n  }\n\n  return nodes.filter(function (node) {\n    return node.matches(\":not(.\".concat(prefix, \"--menu-option--disabled)\"));\n  });\n}\nexport function getNextNode(current, direction) {\n  var menu = getParentMenu(current);\n  var nodes = getValidNodes(menu);\n  var currentIndex = nodes.indexOf(current);\n  var nextNode = nodes[currentIndex + direction];\n  return nextNode || null;\n}\nexport function getFirstSubNode(node) {\n  var submenu = node.querySelector(\"ul.\".concat(prefix, \"--menu\"));\n\n  if (submenu) {\n    var subnodes = getValidNodes(submenu);\n    return subnodes[0] || null;\n  }\n\n  return null;\n}\nexport function getParentNode(node) {\n  if (node) {\n    var parentNode = node.parentNode.closest(\"li.\".concat(prefix, \"--menu-option\"));\n    return parentNode || null;\n  }\n\n  return null;\n}\nexport function getParentMenu(el) {\n  if (el) {\n    var parentMenu = el.parentNode.closest(\"ul.\".concat(prefix, \"--menu\"));\n    return parentMenu || null;\n  }\n\n  return null;\n}\nexport function clickedElementHasSubnodes(e) {\n  if (e) {\n    var closestFocusableElement = e.target.closest('[tabindex]');\n\n    if ((closestFocusableElement === null || closestFocusableElement === void 0 ? void 0 : closestFocusableElement.tagName) === 'LI') {\n      return getFirstSubNode(closestFocusableElement) !== null;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {number} [value] The value to cap\n * @param {number} [min] The minimum of the range\n * @param {number} [max] The maximum of the range\n * @returns {number} Whether or not the element fits inside the boundaries on the given axis\n */\n\nexport function capWithinRange(value, min, max) {\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [position] The desired position of the element: [x, y]\n * @param {number[]} [boundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {string} [axis=\"x\"] Which axis to check. Either \"x\" or \"y\"\n * @returns {boolean} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction elementFits(elementDimensions, position, boundaries) {\n  var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';\n  var index = axis === 'y' ? 1 : 0;\n  var min = boundaries[index];\n  var max = boundaries[index + 2];\n  var start = position[index];\n  var end = position[index] + elementDimensions[index];\n  return start >= min && end <= max;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [targetBoundaries] The boundaries of the target the element should attach to: [minX, minY, maxX, maxY]\n * @param {number[]} [containerBoundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {number} [preferredDirection=1] Which direction is preferred. Either 1 (right right) or -1 (to left)\n * @returns {object} The determined position and direction of the element: { position: [x, y], direction: 1 | -1 }\n */\n\n\nexport function getPosition(elementDimensions, targetBoundaries, containerBoundaries) {\n  var preferredDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var position = [0, 0];\n  var direction = preferredDirection; // x\n\n  position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  var xFits = elementFits(elementDimensions, position, containerBoundaries, 'x');\n\n  if (!xFits) {\n    direction = direction * -1;\n    position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  } // y\n\n\n  position[1] = targetBoundaries[3];\n  var yFits = elementFits(elementDimensions, position, containerBoundaries, 'y');\n\n  if (!yFits) {\n    position[1] = targetBoundaries[1] - elementDimensions[1];\n  }\n\n  return {\n    position: position,\n    direction: direction\n  };\n}","map":{"version":3,"sources":["/Users/danielcrow/Documents/development/cloudfoundry/datacap-ui/node_modules/carbon-components-react/es/components/Menu/_utils.js"],"names":["settings","prefix","resetFocus","el","_el$querySelectorAll","Array","from","querySelectorAll","forEach","node","tabIndex","focusNode","focus","getValidNodes","list","level","dataset","nodes","submenus","concat","filter","child","some","submenu","contains","matches","getNextNode","current","direction","menu","getParentMenu","currentIndex","indexOf","nextNode","getFirstSubNode","querySelector","subnodes","getParentNode","parentNode","closest","parentMenu","clickedElementHasSubnodes","e","closestFocusableElement","target","tagName","capWithinRange","value","min","max","elementFits","elementDimensions","position","boundaries","axis","arguments","length","undefined","index","start","end","getPosition","targetBoundaries","containerBoundaries","preferredDirection","xFits","yFits"],"mappings":"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","sourcesContent":["import { settings } from 'carbon-components';\nvar prefix = settings.prefix;\nexport function resetFocus(el) {\n  if (el) {\n    var _el$querySelectorAll;\n\n    Array.from((_el$querySelectorAll = el.querySelectorAll('[tabindex=\"0\"]')) !== null && _el$querySelectorAll !== void 0 ? _el$querySelectorAll : []).forEach(function (node) {\n      node.tabIndex = -1;\n    });\n  }\n}\nexport function focusNode(node) {\n  if (node) {\n    node.tabIndex = 0;\n    node.focus();\n  }\n}\nexport function getValidNodes(list) {\n  var level = list.dataset.level;\n  var nodes = [];\n\n  if (level) {\n    var submenus = Array.from(list.querySelectorAll('[data-level]'));\n    nodes = Array.from(list.querySelectorAll(\"li.\".concat(prefix, \"--menu-option\"))).filter(function (child) {\n      return !submenus.some(function (submenu) {\n        return submenu.contains(child);\n      });\n    });\n  }\n\n  return nodes.filter(function (node) {\n    return node.matches(\":not(.\".concat(prefix, \"--menu-option--disabled)\"));\n  });\n}\nexport function getNextNode(current, direction) {\n  var menu = getParentMenu(current);\n  var nodes = getValidNodes(menu);\n  var currentIndex = nodes.indexOf(current);\n  var nextNode = nodes[currentIndex + direction];\n  return nextNode || null;\n}\nexport function getFirstSubNode(node) {\n  var submenu = node.querySelector(\"ul.\".concat(prefix, \"--menu\"));\n\n  if (submenu) {\n    var subnodes = getValidNodes(submenu);\n    return subnodes[0] || null;\n  }\n\n  return null;\n}\nexport function getParentNode(node) {\n  if (node) {\n    var parentNode = node.parentNode.closest(\"li.\".concat(prefix, \"--menu-option\"));\n    return parentNode || null;\n  }\n\n  return null;\n}\nexport function getParentMenu(el) {\n  if (el) {\n    var parentMenu = el.parentNode.closest(\"ul.\".concat(prefix, \"--menu\"));\n    return parentMenu || null;\n  }\n\n  return null;\n}\nexport function clickedElementHasSubnodes(e) {\n  if (e) {\n    var closestFocusableElement = e.target.closest('[tabindex]');\n\n    if ((closestFocusableElement === null || closestFocusableElement === void 0 ? void 0 : closestFocusableElement.tagName) === 'LI') {\n      return getFirstSubNode(closestFocusableElement) !== null;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {number} [value] The value to cap\n * @param {number} [min] The minimum of the range\n * @param {number} [max] The maximum of the range\n * @returns {number} Whether or not the element fits inside the boundaries on the given axis\n */\n\nexport function capWithinRange(value, min, max) {\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [position] The desired position of the element: [x, y]\n * @param {number[]} [boundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {string} [axis=\"x\"] Which axis to check. Either \"x\" or \"y\"\n * @returns {boolean} Whether or not the element fits inside the boundaries on the given axis\n */\n\nfunction elementFits(elementDimensions, position, boundaries) {\n  var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'x';\n  var index = axis === 'y' ? 1 : 0;\n  var min = boundaries[index];\n  var max = boundaries[index + 2];\n  var start = position[index];\n  var end = position[index] + elementDimensions[index];\n  return start >= min && end <= max;\n}\n/**\n * @param {number[]} [elementDimensions] The dimensions of the element: [width, height]\n * @param {number[]} [targetBoundaries] The boundaries of the target the element should attach to: [minX, minY, maxX, maxY]\n * @param {number[]} [containerBoundaries] The boundaries of the container the element should be contained in: [minX, minY, maxX, maxY]\n * @param {number} [preferredDirection=1] Which direction is preferred. Either 1 (right right) or -1 (to left)\n * @returns {object} The determined position and direction of the element: { position: [x, y], direction: 1 | -1 }\n */\n\n\nexport function getPosition(elementDimensions, targetBoundaries, containerBoundaries) {\n  var preferredDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var position = [0, 0];\n  var direction = preferredDirection; // x\n\n  position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  var xFits = elementFits(elementDimensions, position, containerBoundaries, 'x');\n\n  if (!xFits) {\n    direction = direction * -1;\n    position[0] = direction === 1 ? targetBoundaries[0] : targetBoundaries[2] - elementDimensions[0];\n  } // y\n\n\n  position[1] = targetBoundaries[3];\n  var yFits = elementFits(elementDimensions, position, containerBoundaries, 'y');\n\n  if (!yFits) {\n    position[1] = targetBoundaries[1] - elementDimensions[1];\n  }\n\n  return {\n    position: position,\n    direction: direction\n  };\n}"]},"metadata":{},"sourceType":"module"}