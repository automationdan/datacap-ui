{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\n/**\n * `useDelayedState` mirrors `useState` but also allows you to add a delay to\n * when your state updates. You can provide a second argument to `setState`,\n * `delayMs`, which will be the time in milliseconds after which the state is\n * updated.\n *\n * This hook will clean up pending timers in `useEffect` and will cancel any\n * pending timers when a `setState` is called before the state is updated from\n * a previous call\n */\n\nexport function useDelayedState(initialState) {\n  var _useState = useState(initialState),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var timeoutId = useRef(null); // We use `useCallback` to match the signature of React's `useState` which will\n  // always return the same reference for the `setState` updater\n\n  var setStateWithDelay = useCallback(function (stateToSet) {\n    var delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    clearTimeout(timeoutId.current);\n    timeoutId.current = null;\n\n    if (delayMs === 0) {\n      setState(stateToSet);\n      return;\n    }\n\n    timeoutId.current = setTimeout(function () {\n      setState(stateToSet);\n      timeoutId.current = null;\n    }, delayMs);\n  }, []);\n  useEffect(function () {\n    return function () {\n      clearTimeout(timeoutId.current);\n    };\n  }, []);\n  return [state, setStateWithDelay];\n}","map":{"version":3,"sources":["/Users/danielcrow/Documents/development/cloudfoundry/datacap-ui/node_modules/carbon-components-react/es/internal/useDelayedState.js"],"names":["_slicedToArray","useCallback","useEffect","useRef","useState","useDelayedState","initialState","_useState","_useState2","state","setState","timeoutId","setStateWithDelay","stateToSet","delayMs","arguments","length","undefined","clearTimeout","current","setTimeout"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,sCAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,CAAyBC,YAAzB,EAAuC;AAC5C,MAAIC,SAAS,GAAGH,QAAQ,CAACE,YAAD,CAAxB;AAAA,MACIE,UAAU,GAAGR,cAAc,CAACO,SAAD,EAAY,CAAZ,CAD/B;AAAA,MAEIE,KAAK,GAAGD,UAAU,CAAC,CAAD,CAFtB;AAAA,MAGIE,QAAQ,GAAGF,UAAU,CAAC,CAAD,CAHzB;;AAKA,MAAIG,SAAS,GAAGR,MAAM,CAAC,IAAD,CAAtB,CAN4C,CAMd;AAC9B;;AAEA,MAAIS,iBAAiB,GAAGX,WAAW,CAAC,UAAUY,UAAV,EAAsB;AACxD,QAAIC,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACAG,IAAAA,YAAY,CAACP,SAAS,CAACQ,OAAX,CAAZ;AACAR,IAAAA,SAAS,CAACQ,OAAV,GAAoB,IAApB;;AAEA,QAAIL,OAAO,KAAK,CAAhB,EAAmB;AACjBJ,MAAAA,QAAQ,CAACG,UAAD,CAAR;AACA;AACD;;AAEDF,IAAAA,SAAS,CAACQ,OAAV,GAAoBC,UAAU,CAAC,YAAY;AACzCV,MAAAA,QAAQ,CAACG,UAAD,CAAR;AACAF,MAAAA,SAAS,CAACQ,OAAV,GAAoB,IAApB;AACD,KAH6B,EAG3BL,OAH2B,CAA9B;AAID,GAdkC,EAchC,EAdgC,CAAnC;AAeAZ,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,YAAY;AACjBgB,MAAAA,YAAY,CAACP,SAAS,CAACQ,OAAX,CAAZ;AACD,KAFD;AAGD,GAJQ,EAIN,EAJM,CAAT;AAKA,SAAO,CAACV,KAAD,EAAQG,iBAAR,CAAP;AACD","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\n/**\n * Copyright IBM Corp. 2016, 2018\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { useCallback, useEffect, useRef, useState } from 'react';\n/**\n * `useDelayedState` mirrors `useState` but also allows you to add a delay to\n * when your state updates. You can provide a second argument to `setState`,\n * `delayMs`, which will be the time in milliseconds after which the state is\n * updated.\n *\n * This hook will clean up pending timers in `useEffect` and will cancel any\n * pending timers when a `setState` is called before the state is updated from\n * a previous call\n */\n\nexport function useDelayedState(initialState) {\n  var _useState = useState(initialState),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var timeoutId = useRef(null); // We use `useCallback` to match the signature of React's `useState` which will\n  // always return the same reference for the `setState` updater\n\n  var setStateWithDelay = useCallback(function (stateToSet) {\n    var delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    clearTimeout(timeoutId.current);\n    timeoutId.current = null;\n\n    if (delayMs === 0) {\n      setState(stateToSet);\n      return;\n    }\n\n    timeoutId.current = setTimeout(function () {\n      setState(stateToSet);\n      timeoutId.current = null;\n    }, delayMs);\n  }, []);\n  useEffect(function () {\n    return function () {\n      clearTimeout(timeoutId.current);\n    };\n  }, []);\n  return [state, setStateWithDelay];\n}"]},"metadata":{},"sourceType":"module"}