import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "className", "leftOverflowButtonProps", "light", "onSelectionChange", "rightOverflowButtonProps", "scrollIntoView", "selected", "selectionMode", "tabContentClassName"];

/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import PropTypes from 'prop-types';
import React, { useState, useRef, useEffect, useCallback } from 'react';
import classNames from 'classnames';
import { ChevronLeft16, ChevronRight16 } from '@carbon/icons-react';
import debounce from 'lodash.debounce';
import { keys, match, matches } from '../../../internal/keyboard';
import TabContent from '../../TabContent';
import deprecate from '../../../prop-types/deprecate';
import { usePrefix } from '../../../internal/usePrefix';
var ContainedTabs = /*#__PURE__*/React.forwardRef(function ContainedTabs(_ref, ref) {
  var _classNames2, _classNames3;

  var children = _ref.children,
      className = _ref.className,
      leftOverflowButtonProps = _ref.leftOverflowButtonProps,
      _ref$light = _ref.light,
      light = _ref$light === void 0 ? false : _ref$light,
      onSelectionChange = _ref.onSelectionChange,
      rightOverflowButtonProps = _ref.rightOverflowButtonProps,
      _ref$scrollIntoView = _ref.scrollIntoView,
      scrollIntoView = _ref$scrollIntoView === void 0 ? true : _ref$scrollIntoView,
      _ref$selected = _ref.selected,
      selected = _ref$selected === void 0 ? 0 : _ref$selected,
      _ref$selectionMode = _ref.selectionMode,
      selectionMode = _ref$selectionMode === void 0 ? 'automatic' : _ref$selectionMode,
      tabContentClassName = _ref.tabContentClassName,
      other = _objectWithoutProperties(_ref, _excluded);

  var prefix = usePrefix(); //refs

  var tablist = useRef();
  var leftOverflowNavButton = useRef();
  var rightOverflowNavButton = useRef();
  var tabs = useRef([]); //states

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      horizontalOverflow = _useState2[0],
      setHorizontalOverflow = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      tablistClientWidth = _useState4[0],
      setTablistClientWidth = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = _slicedToArray(_useState5, 2),
      tablistScrollWidth = _useState6[0],
      setTablistScrollWidth = _useState6[1];

  var _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      tablistScrollLeft = _useState8[0],
      setTablistScrollLeft = _useState8[1];

  var _useState9 = useState(selected),
      _useState10 = _slicedToArray(_useState9, 2),
      isSelected = _useState10[0],
      setIsSelected = _useState10[1];

  var _useState11 = useState(isSelected),
      _useState12 = _slicedToArray(_useState11, 2),
      prevSelected = _useState12[0],
      setPrevSelected = _useState12[1];
  /**
   * prop + state alignment - getDerivedStateFromProps
   * only update if selected prop changes
   */


  useEffect(function () {
    if (selected !== prevSelected) {
      setIsSelected(selected);
      setPrevSelected(selected);
    }
  }, [selected]); //eslint-disable-line react-hooks/exhaustive-deps
  // width of the overflow buttons

  var OVERFLOW_BUTTON_OFFSET = 40;
  /**
   * `scroll` event handler to save tablist clientWidth, scrollWidth, and
   * scrollLeft
   */

  var handleScroll = function handleScroll() {
    if (!(tablist !== null && tablist !== void 0 && tablist.current)) {
      return;
    }

    var _tablist$current = tablist.current,
        clientWidth = _tablist$current.clientWidth,
        scrollLeft = _tablist$current.scrollLeft,
        scrollWidth = _tablist$current.scrollWidth;
    setTablistClientWidth(clientWidth);
    setTablistScrollWidth(scrollWidth);
    setTablistScrollLeft(scrollLeft);
    setHorizontalOverflow(scrollWidth > clientWidth);
  };
  /**
   * The debounced version of the `resize` event handler.
   * @type {Function}
   * @private
   */


  var _debouncedHandleWindowResize = useRef();

  var _handleWindowResize = handleScroll;
  /**
   * returns all tabs that are not disabled
   * used for keyboard navigation
   */

  var getEnabledTabs = function getEnabledTabs() {
    return React.Children.toArray(children).reduce(function (enabledTabs, tab, index) {
      return !tab.props.disabled ? enabledTabs.concat(index) : enabledTabs;
    }, []);
  };
  /**
   * returns the index of the next tab we are going to when navigating L/R arrow keys (i.e. 0, 1, 2)
   * used in handleTabKeyDown to get the next index after keyboard arrow evt, which then updates selected tab
   */


  var getNextIndex = function getNextIndex(index, direction) {
    var enabledTabs = getEnabledTabs();
    var nextIndex = Math.max(enabledTabs.indexOf(index) + direction, // For `tab` not found in `enabledTabs`
    -1);
    var nextIndexLooped = nextIndex >= 0 && nextIndex < enabledTabs.length ? nextIndex : nextIndex - Math.sign(nextIndex) * enabledTabs.length;
    return enabledTabs[nextIndexLooped];
  };
  /**
   * used as second argument for getNextIndex(i,d)
   * returns -1, 1 or 0 depending on arrow key
   * number is then used in math calculations to find the index of the next tab we are navigating to
   */


  var getDirection = function getDirection(evt) {
    if (match(evt, keys.ArrowLeft)) {
      return -1;
    }

    if (match(evt, keys.ArrowRight)) {
      return 1;
    }

    return 0;
  };

  var getTabAt = useCallback(function (index) {
    return tabs.current[index] || React.Children.toArray(children)[index];
  }, [tabs, children]);

  var scrollTabIntoView = function scrollTabIntoView(event, _ref2) {
    var index = _ref2.index;
    var tab = getTabAt(index);

    if (matches(event, [keys.ArrowLeft, keys.ArrowRight]) || event.type === 'click') {
      var _tab$tabAnchor, _tab$tabAnchor2;

      var currentScrollLeft = tablistScrollLeft;
      tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor = tab.tabAnchor) === null || _tab$tabAnchor === void 0 ? void 0 : _tab$tabAnchor.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
      tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor2 = tab.tabAnchor) === null || _tab$tabAnchor2 === void 0 ? void 0 : _tab$tabAnchor2.focus();
      var newScrollLeft = tablist.current.scrollLeft;

      if (newScrollLeft > currentScrollLeft) {
        tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET;
      }
    }
  };
  /**
   * selecting tab on click and on keyboard nav
   * index = tab to be selected, returned in handleTabKeyDown
   * onSelectionChange = optional prop for event handler
   */


  var selectTabAt = function selectTabAt(event, _ref3) {
    var index = _ref3.index,
        onSelectionChange = _ref3.onSelectionChange;
    scrollTabIntoView(event, {
      index: index
    });

    if (isSelected !== index) {
      setIsSelected(index);
      setPrevSelected(index);

      if (typeof onSelectionChange === 'function') {
        onSelectionChange(index);
      }
    }
  };
  /**
   *  keyboard event handler
   */


  var handleTabKeyDown = function handleTabKeyDown(onSelectionChange) {
    return function (index, evt) {
      if (matches(evt, [keys.Enter, keys.Space])) {
        selectTabAt(evt, {
          index: index,
          onSelectionChange: onSelectionChange
        });
      }

      var nextIndex = function () {
        if (matches(evt, [keys.ArrowLeft, keys.ArrowRight])) {
          return getNextIndex(index, getDirection(evt));
        }

        if (match(evt, keys.Home)) {
          return 0;
        }

        if (match(evt, keys.End)) {
          return getEnabledTabs().pop();
        }
      }();

      var tab = getTabAt(nextIndex); // updating selected tab

      if (matches(evt, [keys.ArrowLeft, keys.ArrowRight, keys.Home, keys.End])) {
        evt.preventDefault();

        if (selectionMode !== 'manual') {
          selectTabAt(evt, {
            index: nextIndex,
            onSelectionChange: onSelectionChange
          });
        } else {
          scrollTabIntoView(evt, {
            index: nextIndex
          });
        }

        tab === null || tab === void 0 ? void 0 : tab.focus();
      }
    };
  };

  var getTabs = function getTabs() {
    return React.Children.map(children, function (tab) {
      return tab;
    });
  };
  /**
   *  click handler
   *  passed down to Tab children as a prop in `tabsWithProps`
   *  following functions (handle*) are Props on Tab.js, see Tab.js for parameters
   */


  var handleTabClick = function handleTabClick(onSelectionChange) {
    return function (index, evt) {
      evt.preventDefault();
      selectTabAt(evt, {
        index: index,
        onSelectionChange: onSelectionChange
      });
    };
  };
  /**
   * creates an array of all the child tab items
   */


  var setTabAt = function setTabAt(index, tabRef) {
    tabs.current[index] = tabRef;
  };

  var overflowNavInterval = null;
  /**
   * group - overflow scroll
   * scrolling via overflow btn click
   * click handler for scrollable tabs L/R arrow buttons
   */

  var handleOverflowNavClick = function handleOverflowNavClick(_, _ref4) {
    var direction = _ref4.direction,
        _ref4$multiplier = _ref4.multiplier,
        multiplier = _ref4$multiplier === void 0 ? 10 : _ref4$multiplier;

    // account for overflow button appearing and causing tablist width change
    var _tablist$current2 = tablist === null || tablist === void 0 ? void 0 : tablist.current,
        clientWidth = _tablist$current2.clientWidth,
        scrollLeft = _tablist$current2.scrollLeft,
        scrollWidth = _tablist$current2.scrollWidth;

    if (direction === 1 && !scrollLeft) {
      tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET;
    }

    tablist.current.scrollLeft += direction * multiplier;
    var leftEdgeReached = direction === -1 && scrollLeft < OVERFLOW_BUTTON_OFFSET;
    var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - OVERFLOW_BUTTON_OFFSET;

    if (leftEdgeReached || rightEdgeReached) {
      if (leftEdgeReached) {
        var _rightOverflowNavButt;

        rightOverflowNavButton === null || rightOverflowNavButton === void 0 ? void 0 : (_rightOverflowNavButt = rightOverflowNavButton.current) === null || _rightOverflowNavButt === void 0 ? void 0 : _rightOverflowNavButt.focus();
      }

      if (rightEdgeReached) {
        var _leftOverflowNavButto;

        leftOverflowNavButton === null || leftOverflowNavButton === void 0 ? void 0 : (_leftOverflowNavButto = leftOverflowNavButton.current) === null || _leftOverflowNavButto === void 0 ? void 0 : _leftOverflowNavButto.focus();
      }
    }
  };
  /**
   * group - overflow scroll
   * scrolling w/ mouse event
   * mousedown handler for scrollable tabs
   */


  var handleOverflowNavMouseDown = function handleOverflowNavMouseDown(event, _ref5) {
    var direction = _ref5.direction;

    // disregard mouse buttons aside from LMB
    if (event.buttons !== 1) {
      return;
    }

    overflowNavInterval = setInterval(function () {
      var _tablist$current3 = tablist === null || tablist === void 0 ? void 0 : tablist.current,
          clientWidth = _tablist$current3.clientWidth,
          scrollLeft = _tablist$current3.scrollLeft,
          scrollWidth = _tablist$current3.scrollWidth; // clear interval if scroll reaches left or right edge


      var leftEdgeReached = direction === -1 && scrollLeft < OVERFLOW_BUTTON_OFFSET;
      var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - OVERFLOW_BUTTON_OFFSET;

      if (leftEdgeReached || rightEdgeReached) {
        clearInterval(overflowNavInterval);
      } // account for overflow button appearing and causing tablist width change


      handleOverflowNavClick(event, {
        direction: direction
      });
    });
  };
  /**
   * group - overflow scroll
   * scrolling w/ mouse event
   * mouseup handler for scrollable tabs
   */


  var handleOverflowNavMouseUp = function handleOverflowNavMouseUp() {
    clearInterval(overflowNavInterval);
  };
  /**
   * only run once - component did mount equivalent
   */


  useEffect(function () {
    _debouncedHandleWindowResize.current = debounce(_handleWindowResize, 200);

    _handleWindowResize();

    window.addEventListener('resize', _debouncedHandleWindowResize.current); // scroll selected tab into view on mount

    var _ref6 = (tablist === null || tablist === void 0 ? void 0 : tablist.current) || {},
        clientWidth = _ref6.clientWidth,
        scrollLeft = _ref6.scrollLeft,
        scrollWidth = _ref6.scrollWidth;

    setTablistClientWidth(clientWidth);
    setTablistScrollWidth(scrollWidth);
    setTablistScrollLeft(scrollLeft);
    var tab = getTabAt(isSelected);
    var horizontalOverflow = scrollWidth > clientWidth;

    if (horizontalOverflow) {
      var _tab$tabAnchor3, _tab$tabAnchor4, _tab$tabAnchor5;

      var _leftOverflowNavButtonHidden = (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor3 = tab.tabAnchor) === null || _tab$tabAnchor3 === void 0 ? void 0 : _tab$tabAnchor3.getBoundingClientRect().right) < (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor4 = tab.tabAnchor) === null || _tab$tabAnchor4 === void 0 ? void 0 : _tab$tabAnchor4.offsetParent.getBoundingClientRect().right);

      var _rightOverflowNavButtonHidden = scrollLeft + clientWidth === scrollWidth;

      scrollIntoView && (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor5 = tab.tabAnchor) === null || _tab$tabAnchor5 === void 0 ? void 0 : _tab$tabAnchor5.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      })); // account for overflow buttons in scroll position on mount

      if (!_leftOverflowNavButtonHidden && !_rightOverflowNavButtonHidden) {
        tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET * 2;
      }
    } //component will unmount equivalent


    return function () {
      if (_debouncedHandleWindowResize.current) {
        _debouncedHandleWindowResize.current.cancel();
      }

      window.removeEventListener('resize', _debouncedHandleWindowResize.current);
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  /**
   * component did update equivalent
   */

  useEffect(function () {
    // compare current tablist properties to current state
    var _tablist$current4 = tablist.current,
        currentTablistClientWidth = _tablist$current4.clientWidth,
        currentTablistScrollLeft = _tablist$current4.scrollLeft,
        currentTablistScrollWidth = _tablist$current4.scrollWidth;

    if (currentTablistClientWidth !== tablistClientWidth || currentTablistScrollLeft !== tablistScrollLeft || currentTablistScrollWidth !== tablistScrollWidth) {
      setTablistClientWidth(currentTablistClientWidth);
      setTablistScrollWidth(currentTablistScrollWidth);
      setTablistScrollLeft(currentTablistScrollLeft);
      setHorizontalOverflow(currentTablistScrollWidth > currentTablistClientWidth);
    }

    if (scrollIntoView && prevSelected !== isSelected) {
      var _getTabAt, _getTabAt$tabAnchor;

      (_getTabAt = getTabAt(isSelected)) === null || _getTabAt === void 0 ? void 0 : (_getTabAt$tabAnchor = _getTabAt.tabAnchor) === null || _getTabAt$tabAnchor === void 0 ? void 0 : _getTabAt$tabAnchor.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  }, [isSelected, prevSelected, scrollIntoView, tablistClientWidth, tablistScrollLeft, tablistScrollWidth, getTabAt]);
  /**
   * The tab panel acts like a tab panel when the screen is wider, but acts
   * like a select list when the screen is narrow.  In the wide case we want
   * to allow the user to use the tab key to set the focus in the tab panel
   * and then use the left and right arrow keys to navigate the tabs.  In the
   * narrow case we want to use the tab key to select different options in
   * the list.
   *
   * We set the tab index based on the different states so the browser will treat
   * the whole tab panel as a single focus component when it looks like a tab
   * panel and separate components when it looks like a select list.
   */

  var tabsWithProps = getTabs().map(function (tab, index) {
    var tabIndex = index === isSelected ? 0 : -1;
    var newTab = /*#__PURE__*/React.cloneElement(tab, {
      index: index,
      selected: index === isSelected,
      handleTabClick: handleTabClick(onSelectionChange),
      tabIndex: tabIndex,
      ref: function ref(e) {
        setTabAt(index, e);
      },
      handleTabKeyDown: handleTabKeyDown(onSelectionChange)
    });
    return newTab;
  });
  var tabContentWithProps = React.Children.map(tabsWithProps, function (tab) {
    var _tab$props = tab.props,
        tabId = _tab$props.id,
        children = _tab$props.children,
        selected = _tab$props.selected,
        _tab$props$renderCont = _tab$props.renderContent,
        Content = _tab$props$renderCont === void 0 ? TabContent : _tab$props$renderCont;
    return /*#__PURE__*/React.createElement(Content, {
      id: tabId && "".concat(tabId, "__panel"),
      className: tabContentClassName,
      hidden: !selected,
      selected: selected,
      "aria-labelledby": tabId
    }, children);
  });
  var leftOverflowNavButtonHidden = !horizontalOverflow || !tablistScrollLeft;
  var rightOverflowNavButtonHidden = !horizontalOverflow || tablistScrollLeft + tablistClientWidth === tablistScrollWidth;
  var classes = {
    // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
    tabs: classNames(className, // `${prefix}--tabs`,
    "".concat(prefix, "--tabs--scrollable"), "".concat(prefix, "--tabs--scrollable--container"), _defineProperty({}, "".concat(prefix, "--tabs--scrollable--light"), light)),
    // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
    tablist: classNames( // `${prefix}--tabs__nav`,
    "".concat(prefix, "--tabs--scrollable__nav")),
    leftOverflowButtonClasses: classNames((_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefix, "--tab--overflow-nav-button"), horizontalOverflow), _defineProperty(_classNames2, "".concat(prefix, "--tab--overflow-nav-button--hidden"), leftOverflowNavButtonHidden), _classNames2)),
    rightOverflowButtonClasses: classNames((_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefix, "--tab--overflow-nav-button"), horizontalOverflow), _defineProperty(_classNames3, "".concat(prefix, "--tab--overflow-nav-button--hidden"), rightOverflowNavButtonHidden), _classNames3))
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends({
    className: classes.tabs,
    ref: ref
  }, other), /*#__PURE__*/React.createElement("button", _extends({
    "aria-hidden": "true",
    "aria-label": "Scroll left",
    className: classes.leftOverflowButtonClasses,
    onClick: function onClick(_) {
      return handleOverflowNavClick(_, {
        direction: -1
      });
    },
    onMouseDown: function onMouseDown(event) {
      return handleOverflowNavMouseDown(event, {
        direction: -1
      });
    },
    onMouseUp: handleOverflowNavMouseUp,
    ref: leftOverflowNavButton,
    tabIndex: "-1",
    type: "button"
  }, leftOverflowButtonProps), /*#__PURE__*/React.createElement(ChevronLeft16, null)), !leftOverflowNavButtonHidden && /*#__PURE__*/React.createElement("div", {
    className: "".concat(prefix, "--tabs__overflow-indicator--left")
  }), /*#__PURE__*/React.createElement("ul", {
    role: "tablist",
    tabIndex: -1,
    className: classes.tablist,
    ref: tablist,
    onScroll: handleScroll
  }, tabsWithProps), !rightOverflowNavButtonHidden && /*#__PURE__*/React.createElement("div", {
    className: "".concat(prefix, "--tabs__overflow-indicator--right")
  }), /*#__PURE__*/React.createElement("button", _extends({
    "aria-hidden": "true",
    "aria-label": "Scroll right",
    className: classes.rightOverflowButtonClasses,
    onClick: function onClick(_) {
      return handleOverflowNavClick(_, {
        direction: 1
      });
    },
    onMouseDown: function onMouseDown(event) {
      return handleOverflowNavMouseDown(event, {
        direction: 1
      });
    },
    onMouseUp: handleOverflowNavMouseUp,
    ref: rightOverflowNavButton,
    tabIndex: "-1",
    type: "button"
  }, rightOverflowButtonProps), /*#__PURE__*/React.createElement(ChevronRight16, null))), tabContentWithProps);
});
ContainedTabs.propTypes = {
  /**
   * Pass in a collection of <Tab> children to be rendered depending on the
   * currently selected tab
   */
  children: PropTypes.node,

  /**
   * Provide a className that is applied to the root <div> component for the
   * <Tabs>
   */
  className: PropTypes.string,

  /**
   * Specify whether the Tab content is hidden
   */
  hidden: PropTypes.bool,

  /**
   * Provide the props that describe the left overflow button
   */
  leftOverflowButtonProps: PropTypes.object,

  /**
   * Specify whether or not to use the light component variant
   */
  light: deprecate(PropTypes.bool, 'The light prop has been deprecated in v11 in favor of our new layering model that uses the Layer component'),

  /**
   * Optionally provide an `onClick` handler that is invoked when a <Tab> is
   * clicked
   */
  onClick: PropTypes.func,

  /**
   * Optionally provide an `onKeyDown` handler that is invoked when keyed
   * navigation is triggered
   */
  onKeyDown: PropTypes.func,

  /**
   * Provide an optional handler that is called whenever the selection
   * changes. This method is called with the index of the tab that was
   * selected
   */
  onSelectionChange: PropTypes.func,

  /**
   * Provide the props that describe the right overflow button
   */
  rightOverflowButtonProps: PropTypes.object,

  /**
   * Choose whether or not to automatically scroll to newly selected tabs
   * on component rerender
   */
  scrollIntoView: PropTypes.bool,

  /**
   * Optionally provide an index for the currently selected <Tab>
   */
  selected: PropTypes.number,

  /**
   * Choose whether or not to automatically change selection on focus
   */
  selectionMode: PropTypes.oneOf(['automatic', 'manual']),

  /**
   * Provide a className that is applied to the <TabContent> components
   */
  tabContentClassName: PropTypes.string //   /**
  //    * Provide the type of Tab
  //    */
  //   type: PropTypes.oneOf(['default', 'container']),

};
export default ContainedTabs;