"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _iconsReact = require("@carbon/icons-react");

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _keyboard = require("../../../internal/keyboard");

var _TabContent = _interopRequireDefault(require("../../TabContent"));

var _deprecate = _interopRequireDefault(require("../../../prop-types/deprecate"));

var _usePrefix = require("../../../internal/usePrefix");

var _excluded = ["children", "className", "leftOverflowButtonProps", "light", "onSelectionChange", "rightOverflowButtonProps", "scrollIntoView", "selected", "selectionMode", "tabContentClassName"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Tabs = /*#__PURE__*/_react.default.forwardRef(function Tabs(_ref, ref) {
  var _classNames2, _classNames3;

  var children = _ref.children,
      className = _ref.className,
      leftOverflowButtonProps = _ref.leftOverflowButtonProps,
      _ref$light = _ref.light,
      light = _ref$light === void 0 ? false : _ref$light,
      onSelectionChange = _ref.onSelectionChange,
      rightOverflowButtonProps = _ref.rightOverflowButtonProps,
      _ref$scrollIntoView = _ref.scrollIntoView,
      scrollIntoView = _ref$scrollIntoView === void 0 ? true : _ref$scrollIntoView,
      _ref$selected = _ref.selected,
      selected = _ref$selected === void 0 ? 0 : _ref$selected,
      _ref$selectionMode = _ref.selectionMode,
      selectionMode = _ref$selectionMode === void 0 ? 'automatic' : _ref$selectionMode,
      tabContentClassName = _ref.tabContentClassName,
      other = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var prefix = (0, _usePrefix.usePrefix)(); //refs

  var tablist = (0, _react.useRef)();
  var leftOverflowNavButton = (0, _react.useRef)();
  var rightOverflowNavButton = (0, _react.useRef)();
  var tabs = (0, _react.useRef)([]); //states

  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      horizontalOverflow = _useState2[0],
      setHorizontalOverflow = _useState2[1];

  var _useState3 = (0, _react.useState)(null),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      tablistClientWidth = _useState4[0],
      setTablistClientWidth = _useState4[1];

  var _useState5 = (0, _react.useState)(null),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      tablistScrollWidth = _useState6[0],
      setTablistScrollWidth = _useState6[1];

  var _useState7 = (0, _react.useState)(null),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      tablistScrollLeft = _useState8[0],
      setTablistScrollLeft = _useState8[1];

  var _useState9 = (0, _react.useState)(selected),
      _useState10 = (0, _slicedToArray2.default)(_useState9, 2),
      isSelected = _useState10[0],
      setIsSelected = _useState10[1];

  var _useState11 = (0, _react.useState)(isSelected),
      _useState12 = (0, _slicedToArray2.default)(_useState11, 2),
      prevSelected = _useState12[0],
      setPrevSelected = _useState12[1];
  /**
   * prop + state alignment - getDerivedStateFromProps
   * only update if selected prop changes
   */


  (0, _react.useEffect)(function () {
    if (selected !== prevSelected) {
      setIsSelected(selected);
      setPrevSelected(selected);
    }
  }, [selected]); //eslint-disable-line react-hooks/exhaustive-deps
  // width of the overflow buttons

  var OVERFLOW_BUTTON_OFFSET = 40;
  /**
   * `scroll` event handler to save tablist clientWidth, scrollWidth, and
   * scrollLeft
   */

  var handleScroll = function handleScroll() {
    if (!(tablist !== null && tablist !== void 0 && tablist.current)) {
      return;
    }

    var _tablist$current = tablist.current,
        clientWidth = _tablist$current.clientWidth,
        scrollLeft = _tablist$current.scrollLeft,
        scrollWidth = _tablist$current.scrollWidth;
    setTablistClientWidth(clientWidth);
    setTablistScrollWidth(scrollWidth);
    setTablistScrollLeft(scrollLeft);
    setHorizontalOverflow(scrollWidth > clientWidth);
  };
  /**
   * The debounced version of the `resize` event handler.
   * @type {Function}
   * @private
   */


  var _debouncedHandleWindowResize = (0, _react.useRef)();

  var _handleWindowResize = handleScroll;
  /**
   * returns all tabs that are not disabled
   * used for keyboard navigation
   */

  var getEnabledTabs = function getEnabledTabs() {
    return _react.default.Children.toArray(children).reduce(function (enabledTabs, tab, index) {
      return !tab.props.disabled ? enabledTabs.concat(index) : enabledTabs;
    }, []);
  };
  /**
   * returns the index of the next tab we are going to when navigating L/R arrow keys (i.e. 0, 1, 2)
   * used in handleTabKeyDown to get the next index after keyboard arrow evt, which then updates selected tab
   */


  var getNextIndex = function getNextIndex(index, direction) {
    var enabledTabs = getEnabledTabs();
    var nextIndex = Math.max(enabledTabs.indexOf(index) + direction, // For `tab` not found in `enabledTabs`
    -1);
    var nextIndexLooped = nextIndex >= 0 && nextIndex < enabledTabs.length ? nextIndex : nextIndex - Math.sign(nextIndex) * enabledTabs.length;
    return enabledTabs[nextIndexLooped];
  };
  /**
   * used as second argument for getNextIndex(i,d)
   * returns -1, 1 or 0 depending on arrow key
   * number is then used in math calculations to find the index of the next tab we are navigating to
   */


  var getDirection = function getDirection(evt) {
    if ((0, _keyboard.match)(evt, _keyboard.keys.ArrowLeft)) {
      return -1;
    }

    if ((0, _keyboard.match)(evt, _keyboard.keys.ArrowRight)) {
      return 1;
    }

    return 0;
  };

  var getTabAt = (0, _react.useCallback)(function (index) {
    return tabs.current[index] || _react.default.Children.toArray(children)[index];
  }, [tabs, children]);

  var scrollTabIntoView = function scrollTabIntoView(event, _ref2) {
    var index = _ref2.index;
    var tab = getTabAt(index);

    if ((0, _keyboard.matches)(event, [_keyboard.keys.ArrowLeft, _keyboard.keys.ArrowRight]) || event.type === 'click') {
      var _tab$tabAnchor, _tab$tabAnchor2;

      var currentScrollLeft = tablistScrollLeft;
      tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor = tab.tabAnchor) === null || _tab$tabAnchor === void 0 ? void 0 : _tab$tabAnchor.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
      tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor2 = tab.tabAnchor) === null || _tab$tabAnchor2 === void 0 ? void 0 : _tab$tabAnchor2.focus();
      var newScrollLeft = tablist.current.scrollLeft;

      if (newScrollLeft > currentScrollLeft) {
        tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET;
      }
    }
  };
  /**
   * selecting tab on click and on keyboard nav
   * index = tab to be selected, returned in handleTabKeyDown
   * onSelectionChange = optional prop for event handler
   */


  var selectTabAt = function selectTabAt(event, _ref3) {
    var index = _ref3.index,
        onSelectionChange = _ref3.onSelectionChange;
    scrollTabIntoView(event, {
      index: index
    });

    if (isSelected !== index) {
      setIsSelected(index);
      setPrevSelected(index);

      if (typeof onSelectionChange === 'function') {
        onSelectionChange(index);
      }
    }
  };
  /**
   *  keyboard event handler
   */


  var handleTabKeyDown = function handleTabKeyDown(onSelectionChange) {
    return function (index, evt) {
      if ((0, _keyboard.matches)(evt, [_keyboard.keys.Enter, _keyboard.keys.Space])) {
        selectTabAt(evt, {
          index: index,
          onSelectionChange: onSelectionChange
        });
      }

      var nextIndex = function () {
        if ((0, _keyboard.matches)(evt, [_keyboard.keys.ArrowLeft, _keyboard.keys.ArrowRight])) {
          return getNextIndex(index, getDirection(evt));
        }

        if ((0, _keyboard.match)(evt, _keyboard.keys.Home)) {
          return 0;
        }

        if ((0, _keyboard.match)(evt, _keyboard.keys.End)) {
          return getEnabledTabs().pop();
        }
      }();

      var tab = getTabAt(nextIndex); // updating selected tab

      if ((0, _keyboard.matches)(evt, [_keyboard.keys.ArrowLeft, _keyboard.keys.ArrowRight, _keyboard.keys.Home, _keyboard.keys.End])) {
        evt.preventDefault();

        if (selectionMode !== 'manual') {
          selectTabAt(evt, {
            index: nextIndex,
            onSelectionChange: onSelectionChange
          });
        } else {
          scrollTabIntoView(evt, {
            index: nextIndex
          });
        }

        tab === null || tab === void 0 ? void 0 : tab.focus();
      }
    };
  };

  var getTabs = function getTabs() {
    return _react.default.Children.map(children, function (tab) {
      return tab;
    });
  };
  /**
   *  click handler
   *  passed down to Tab children as a prop in `tabsWithProps`
   *  following functions (handle*) are Props on Tab.js, see Tab.js for parameters
   */


  var handleTabClick = function handleTabClick(onSelectionChange) {
    return function (index, evt) {
      evt.preventDefault();
      selectTabAt(evt, {
        index: index,
        onSelectionChange: onSelectionChange
      });
    };
  };
  /**
   * creates an array of all the child tab items
   */


  var setTabAt = function setTabAt(index, tabRef) {
    tabs.current[index] = tabRef;
  };

  var overflowNavInterval = null;
  /**
   * group - overflow scroll
   * scrolling via overflow btn click
   * click handler for scrollable tabs L/R arrow buttons
   */

  var handleOverflowNavClick = function handleOverflowNavClick(_, _ref4) {
    var direction = _ref4.direction,
        _ref4$multiplier = _ref4.multiplier,
        multiplier = _ref4$multiplier === void 0 ? 10 : _ref4$multiplier;

    // account for overflow button appearing and causing tablist width change
    var _tablist$current2 = tablist === null || tablist === void 0 ? void 0 : tablist.current,
        clientWidth = _tablist$current2.clientWidth,
        scrollLeft = _tablist$current2.scrollLeft,
        scrollWidth = _tablist$current2.scrollWidth;

    if (direction === 1 && !scrollLeft) {
      tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET;
    }

    tablist.current.scrollLeft += direction * multiplier;
    var leftEdgeReached = direction === -1 && scrollLeft < OVERFLOW_BUTTON_OFFSET;
    var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - OVERFLOW_BUTTON_OFFSET;

    if (leftEdgeReached || rightEdgeReached) {
      if (leftEdgeReached) {
        var _rightOverflowNavButt;

        rightOverflowNavButton === null || rightOverflowNavButton === void 0 ? void 0 : (_rightOverflowNavButt = rightOverflowNavButton.current) === null || _rightOverflowNavButt === void 0 ? void 0 : _rightOverflowNavButt.focus();
      }

      if (rightEdgeReached) {
        var _leftOverflowNavButto;

        leftOverflowNavButton === null || leftOverflowNavButton === void 0 ? void 0 : (_leftOverflowNavButto = leftOverflowNavButton.current) === null || _leftOverflowNavButto === void 0 ? void 0 : _leftOverflowNavButto.focus();
      }
    }
  };
  /**
   * group - overflow scroll
   * scrolling w/ mouse event
   * mousedown handler for scrollable tabs
   */


  var handleOverflowNavMouseDown = function handleOverflowNavMouseDown(event, _ref5) {
    var direction = _ref5.direction;

    // disregard mouse buttons aside from LMB
    if (event.buttons !== 1) {
      return;
    }

    overflowNavInterval = setInterval(function () {
      var _tablist$current3 = tablist === null || tablist === void 0 ? void 0 : tablist.current,
          clientWidth = _tablist$current3.clientWidth,
          scrollLeft = _tablist$current3.scrollLeft,
          scrollWidth = _tablist$current3.scrollWidth; // clear interval if scroll reaches left or right edge


      var leftEdgeReached = direction === -1 && scrollLeft < OVERFLOW_BUTTON_OFFSET;
      var rightEdgeReached = direction === 1 && scrollLeft + clientWidth >= scrollWidth - OVERFLOW_BUTTON_OFFSET;

      if (leftEdgeReached || rightEdgeReached) {
        clearInterval(overflowNavInterval);
      } // account for overflow button appearing and causing tablist width change


      handleOverflowNavClick(event, {
        direction: direction
      });
    });
  };
  /**
   * group - overflow scroll
   * scrolling w/ mouse event
   * mouseup handler for scrollable tabs
   */


  var handleOverflowNavMouseUp = function handleOverflowNavMouseUp() {
    clearInterval(overflowNavInterval);
  };
  /**
   * only run once - component did mount equivalent
   */


  (0, _react.useEffect)(function () {
    _debouncedHandleWindowResize.current = (0, _lodash.default)(_handleWindowResize, 200);

    _handleWindowResize();

    window.addEventListener('resize', _debouncedHandleWindowResize.current); // scroll selected tab into view on mount

    var _ref6 = (tablist === null || tablist === void 0 ? void 0 : tablist.current) || {},
        clientWidth = _ref6.clientWidth,
        scrollLeft = _ref6.scrollLeft,
        scrollWidth = _ref6.scrollWidth;

    setTablistClientWidth(clientWidth);
    setTablistScrollWidth(scrollWidth);
    setTablistScrollLeft(scrollLeft);
    var tab = getTabAt(isSelected);
    var horizontalOverflow = scrollWidth > clientWidth;

    if (horizontalOverflow) {
      var _tab$tabAnchor3, _tab$tabAnchor4, _tab$tabAnchor5;

      var _leftOverflowNavButtonHidden = (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor3 = tab.tabAnchor) === null || _tab$tabAnchor3 === void 0 ? void 0 : _tab$tabAnchor3.getBoundingClientRect().right) < (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor4 = tab.tabAnchor) === null || _tab$tabAnchor4 === void 0 ? void 0 : _tab$tabAnchor4.offsetParent.getBoundingClientRect().right);

      var _rightOverflowNavButtonHidden = scrollLeft + clientWidth === scrollWidth;

      scrollIntoView && (tab === null || tab === void 0 ? void 0 : (_tab$tabAnchor5 = tab.tabAnchor) === null || _tab$tabAnchor5 === void 0 ? void 0 : _tab$tabAnchor5.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      })); // account for overflow buttons in scroll position on mount

      if (!_leftOverflowNavButtonHidden && !_rightOverflowNavButtonHidden) {
        tablist.current.scrollLeft += OVERFLOW_BUTTON_OFFSET * 2;
      }
    } //component will unmount equivalent


    return function () {
      if (_debouncedHandleWindowResize.current) {
        _debouncedHandleWindowResize.current.cancel();
      }

      window.removeEventListener('resize', _debouncedHandleWindowResize.current);
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  /**
   * component did update equivalent
   */

  (0, _react.useEffect)(function () {
    // compare current tablist properties to current state
    var _tablist$current4 = tablist.current,
        currentTablistClientWidth = _tablist$current4.clientWidth,
        currentTablistScrollLeft = _tablist$current4.scrollLeft,
        currentTablistScrollWidth = _tablist$current4.scrollWidth;

    if (currentTablistClientWidth !== tablistClientWidth || currentTablistScrollLeft !== tablistScrollLeft || currentTablistScrollWidth !== tablistScrollWidth) {
      setTablistClientWidth(currentTablistClientWidth);
      setTablistScrollWidth(currentTablistScrollWidth);
      setTablistScrollLeft(currentTablistScrollLeft);
      setHorizontalOverflow(currentTablistScrollWidth > currentTablistClientWidth);
    }

    if (scrollIntoView && prevSelected !== isSelected) {
      var _getTabAt, _getTabAt$tabAnchor;

      (_getTabAt = getTabAt(isSelected)) === null || _getTabAt === void 0 ? void 0 : (_getTabAt$tabAnchor = _getTabAt.tabAnchor) === null || _getTabAt$tabAnchor === void 0 ? void 0 : _getTabAt$tabAnchor.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  }, [isSelected, prevSelected, scrollIntoView, tablistClientWidth, tablistScrollLeft, tablistScrollWidth, getTabAt]);
  /**
   * The tab panel acts like a tab panel when the screen is wider, but acts
   * like a select list when the screen is narrow.  In the wide case we want
   * to allow the user to use the tab key to set the focus in the tab panel
   * and then use the left and right arrow keys to navigate the tabs.  In the
   * narrow case we want to use the tab key to select different options in
   * the list.
   *
   * We set the tab index based on the different states so the browser will treat
   * the whole tab panel as a single focus component when it looks like a tab
   * panel and separate components when it looks like a select list.
   */

  var tabsWithProps = getTabs().map(function (tab, index) {
    var tabIndex = index === isSelected ? 0 : -1;

    var newTab = /*#__PURE__*/_react.default.cloneElement(tab, {
      index: index,
      selected: index === isSelected,
      handleTabClick: handleTabClick(onSelectionChange),
      tabIndex: tabIndex,
      ref: function ref(e) {
        setTabAt(index, e);
      },
      handleTabKeyDown: handleTabKeyDown(onSelectionChange)
    });

    return newTab;
  });

  var tabContentWithProps = _react.default.Children.map(tabsWithProps, function (tab) {
    var _tab$props = tab.props,
        tabId = _tab$props.id,
        children = _tab$props.children,
        selected = _tab$props.selected,
        _tab$props$renderCont = _tab$props.renderContent,
        Content = _tab$props$renderCont === void 0 ? _TabContent.default : _tab$props$renderCont;
    return /*#__PURE__*/_react.default.createElement(Content, {
      id: tabId && "".concat(tabId, "__panel"),
      className: tabContentClassName,
      hidden: !selected,
      selected: selected,
      "aria-labelledby": tabId
    }, children);
  });

  var leftOverflowNavButtonHidden = !horizontalOverflow || !tablistScrollLeft;
  var rightOverflowNavButtonHidden = !horizontalOverflow || tablistScrollLeft + tablistClientWidth === tablistScrollWidth;
  var classes = {
    // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
    tabs: (0, _classnames.default)(className, // `${prefix}--tabs`,
    "".concat(prefix, "--tabs--scrollable"), (0, _defineProperty2.default)({}, "".concat(prefix, "--tabs--scrollable--light"), light)),
    // TODO: remove scrollable from classnames in next major release and uncomment classnames that don't contain scrollable
    tablist: (0, _classnames.default)( // `${prefix}--tabs__nav`,
    "".concat(prefix, "--tabs--scrollable__nav")),
    leftOverflowButtonClasses: (0, _classnames.default)((_classNames2 = {}, (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--tab--overflow-nav-button"), horizontalOverflow), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--tab--overflow-nav-button--hidden"), leftOverflowNavButtonHidden), _classNames2)),
    rightOverflowButtonClasses: (0, _classnames.default)((_classNames3 = {}, (0, _defineProperty2.default)(_classNames3, "".concat(prefix, "--tab--overflow-nav-button"), horizontalOverflow), (0, _defineProperty2.default)(_classNames3, "".concat(prefix, "--tab--overflow-nav-button--hidden"), rightOverflowNavButtonHidden), _classNames3))
  };
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
    className: classes.tabs,
    ref: ref
  }, other), /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({
    "aria-hidden": "true",
    "aria-label": "Scroll left",
    className: classes.leftOverflowButtonClasses,
    onClick: function onClick(_) {
      return handleOverflowNavClick(_, {
        direction: -1
      });
    },
    onMouseDown: function onMouseDown(event) {
      return handleOverflowNavMouseDown(event, {
        direction: -1
      });
    },
    onMouseUp: handleOverflowNavMouseUp,
    ref: leftOverflowNavButton,
    tabIndex: "-1",
    type: "button"
  }, leftOverflowButtonProps), /*#__PURE__*/_react.default.createElement(_iconsReact.ChevronLeft16, null)), !leftOverflowNavButtonHidden && /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--tabs__overflow-indicator--left")
  }), /*#__PURE__*/_react.default.createElement("ul", {
    role: "tablist",
    tabIndex: -1,
    className: classes.tablist,
    ref: tablist,
    onScroll: handleScroll
  }, tabsWithProps), !rightOverflowNavButtonHidden && /*#__PURE__*/_react.default.createElement("div", {
    className: "".concat(prefix, "--tabs__overflow-indicator--right")
  }), /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({
    "aria-hidden": "true",
    "aria-label": "Scroll right",
    className: classes.rightOverflowButtonClasses,
    onClick: function onClick(_) {
      return handleOverflowNavClick(_, {
        direction: 1
      });
    },
    onMouseDown: function onMouseDown(event) {
      return handleOverflowNavMouseDown(event, {
        direction: 1
      });
    },
    onMouseUp: handleOverflowNavMouseUp,
    ref: rightOverflowNavButton,
    tabIndex: "-1",
    type: "button"
  }, rightOverflowButtonProps), /*#__PURE__*/_react.default.createElement(_iconsReact.ChevronRight16, null))), tabContentWithProps);
});

Tabs.propTypes = {
  /**
   * Pass in a collection of <Tab> children to be rendered depending on the
   * currently selected tab
   */
  children: _propTypes.default.node,

  /**
   * Provide a className that is applied to the root <div> component for the
   * <Tabs>
   */
  className: _propTypes.default.string,

  /**
   * Specify whether the Tab content is hidden
   */
  hidden: _propTypes.default.bool,

  /**
   * Provide the props that describe the left overflow button
   */
  leftOverflowButtonProps: _propTypes.default.object,

  /**
   * Specify whether or not to use the light component variant
   */
  light: (0, _deprecate.default)(_propTypes.default.bool, 'The light prop has been deprecated in v11 in favor of our new layering model that uses the Layer component'),

  /**
   * Optionally provide an `onClick` handler that is invoked when a <Tab> is
   * clicked
   */
  onClick: _propTypes.default.func,

  /**
   * Optionally provide an `onKeyDown` handler that is invoked when keyed
   * navigation is triggered
   */
  onKeyDown: _propTypes.default.func,

  /**
   * Provide an optional handler that is called whenever the selection
   * changes. This method is called with the index of the tab that was
   * selected
   */
  onSelectionChange: _propTypes.default.func,

  /**
   * Provide the props that describe the right overflow button
   */
  rightOverflowButtonProps: _propTypes.default.object,

  /**
   * Choose whether or not to automatically scroll to newly selected tabs
   * on component rerender
   */
  scrollIntoView: _propTypes.default.bool,

  /**
   * Optionally provide an index for the currently selected <Tab>
   */
  selected: _propTypes.default.number,

  /**
   * Choose whether or not to automatically change selection on focus
   */
  selectionMode: _propTypes.default.oneOf(['automatic', 'manual']),

  /**
   * Provide a className that is applied to the <TabContent> components
   */
  tabContentClassName: _propTypes.default.string
};
var _default = Tabs;
exports.default = _default;